---
phase: 12-shared-component-architecture
plan: 01
type: execute
domain: react-typescript
---

<objective>
Create TypeScript interfaces to support prompt ownership, variants, and author metadata for the public prompt library feature.

Purpose: Establish the type foundation that all subsequent refactoring will depend on. Clean type definitions ensure type-safe refactoring.
Output: New type definitions in `src/types/` that extend the existing Prompt model for multi-source scenarios.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-database-schema/11-SUMMARY.md

# Key files from Phase 11 schema:
@src/types/supabase-generated.ts
@src/types/prompt.ts

# Existing patterns:
@src/lib/storage/types.ts

**Tech stack available:**
- TypeScript 5.5 with path aliases (@/*)
- prompt_visibility enum (from Phase 11): 'private' | 'public'
- saved_prompts junction table (from Phase 11)
- forked_from_prompt_id column (from Phase 11)

**Established patterns:**
- Type definitions in `src/types/`
- Interface naming: PascalCase, no "I" prefix
- Database types auto-generated in `supabase-generated.ts`
- Manual types in domain-specific files (`prompt.ts`, etc.)

**Constraining decisions:**
- Phase 11: Enum for visibility allows future 'unlisted' state
- Phase 11: saved_prompts as junction table for many-to-many
- Phase 11: forked_from uses SET NULL on delete

**Context from exploration:**
Current `Prompt` interface assumes user ownership. For public library:
- Need to track prompt source (user-owned, saved from library, forked)
- Need author metadata for public prompts
- Need variant information for component rendering decisions
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PromptSource and PromptVariant types</name>
  <files>src/types/prompt.ts</files>
  <action>
Add new type definitions to the existing prompt.ts file:

1. **PromptSource** - Discriminated union for where a prompt came from:
   ```typescript
   type PromptSource = 'owned' | 'saved' | 'public';
   ```
   - `owned`: User created this prompt, full control
   - `saved`: User saved this from public library (live-linked, read-only)
   - `public`: Viewing from public library (not in user's vault)

2. **PromptVariant** - For component rendering decisions:
   ```typescript
   type PromptVariant = 'default' | 'compact' | 'library';
   ```
   - `default`: Full card with all actions (dashboard)
   - `compact`: Minimal card (search results, history references)
   - `library`: Public library card (author attribution, save/fork actions)

3. **AuthorInfo** - Author metadata for public prompts:
   ```typescript
   interface AuthorInfo {
     userId: string;
     displayName?: string;  // Future: user profile name
   }
   ```

Place these types near the top of the file, after imports but before the main Prompt interface.

Do NOT modify the existing Prompt interface yet - that's Task 2.
  </action>
  <verify>npm run build passes with no TypeScript errors</verify>
  <done>PromptSource, PromptVariant, and AuthorInfo types exported from prompt.ts</done>
</task>

<task type="auto">
  <name>Task 2: Extend Prompt interface with optional public metadata</name>
  <files>src/types/prompt.ts</files>
  <action>
Extend the existing Prompt interface with optional fields for public library support:

1. Add optional fields to the Prompt interface:
   ```typescript
   interface Prompt {
     // ... existing fields ...

     // Public library metadata (optional - only present for public/saved prompts)
     visibility?: 'private' | 'public';  // Maps to prompt_visibility enum
     authorId?: string;                   // Original author's user_id
     author?: AuthorInfo;                 // Author display info (populated on fetch)

     // Saved prompt tracking (for live-linked prompts)
     sourcePromptId?: string;             // Original prompt ID if saved from library

     // Fork tracking
     forkedFromPromptId?: string;         // Source prompt if this is a fork
   }
   ```

2. Create a helper type for "enriched" prompts that definitely have public metadata:
   ```typescript
   interface PublicPrompt extends Prompt {
     visibility: 'public';
     authorId: string;
     author: AuthorInfo;
   }
   ```

3. Create a type guard function:
   ```typescript
   function isPublicPrompt(prompt: Prompt): prompt is PublicPrompt {
     return prompt.visibility === 'public' && !!prompt.authorId;
   }
   ```

4. Export all new types.

**Important:** Keep existing Prompt fields unchanged. New fields are ALL optional to maintain backward compatibility with existing code.
  </action>
  <verify>npm run build passes, npm run lint passes</verify>
  <done>Prompt interface extended with optional public metadata fields, PublicPrompt type created, type guard exported</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm run lint` passes with no warnings
- [ ] New types are exported from src/types/prompt.ts
- [ ] Existing code continues to work (no breaking changes to Prompt interface)
- [ ] Type guard function correctly narrows types
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors or warnings
- Types are backward compatible (existing components unchanged)
- Foundation ready for Plan 02 component refactoring
</success_criteria>

<output>
After completion, create `.planning/phases/12-shared-component-architecture/12-01-SUMMARY.md`
</output>
