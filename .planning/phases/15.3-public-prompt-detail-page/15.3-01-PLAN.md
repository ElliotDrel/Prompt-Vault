---
phase: 15.3-public-prompt-detail-page
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/storage/supabaseAdapter.ts
  - src/lib/storage/types.ts
  - src/hooks/usePublicPrompt.ts
autonomous: true

must_haves:
  truths:
    - "Fetching a public prompt by ID returns prompt with author info"
    - "Fetching a non-existent or private prompt returns null (not an error)"
    - "Hook provides loading, error, and prompt states"
  artifacts:
    - path: "src/lib/storage/supabaseAdapter.ts"
      provides: "getPublicPromptById method"
      contains: "getPublicPromptById"
    - path: "src/hooks/usePublicPrompt.ts"
      provides: "usePublicPrompt hook"
      exports: ["usePublicPrompt"]
  key_links:
    - from: "src/hooks/usePublicPrompt.ts"
      to: "adapter.prompts.getPublicPromptById"
      via: "TanStack Query queryFn"
      pattern: "adapter\\.prompts\\.getPublicPromptById"
---

<objective>
Add data layer for fetching a single public prompt by ID.

Purpose: Enable the public prompt detail page to fetch individual prompts with author metadata. This is the foundation for PublicPromptDetail.tsx to display public prompts from the Library.

Output: Storage adapter method `getPublicPromptById()` and React hook `usePublicPrompt()` that wraps it with TanStack Query caching.
</objective>

<execution_context>
@C:\Users\2supe\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\2supe\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15.3-public-prompt-detail-page/15.3-CONTEXT.md
@.planning/phases/15.3-public-prompt-detail-page/15.3-RESEARCH.md
@src/lib/storage/supabaseAdapter.ts
@src/lib/storage/types.ts
@src/hooks/usePublicPrompts.ts
@src/types/prompt.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add getPublicPromptById to Storage Adapter</name>
  <files>src/lib/storage/supabaseAdapter.ts, src/lib/storage/types.ts</files>
  <action>
Add `getPublicPromptById(promptId: string): Promise<PublicPrompt | null>` method to SupabasePromptsAdapter class.

Implementation:
1. Add method signature to `PromptsStorageAdapter` interface in types.ts
2. Implement in SupabasePromptsAdapter (after getPublicPrompts method):

```typescript
async getPublicPromptById(promptId: string): Promise<PublicPrompt | null> {
  // Requires authentication - RLS policy allows reading public prompts for any authenticated user
  await requireUserId();

  const { data, error } = await supabase
    .from('prompts')
    .select('id, user_id, title, body, variables, created_at, updated_at, is_pinned, times_used, visibility')
    .eq('id', promptId)
    .eq('visibility', 'public')  // CRITICAL: Only fetch if public
    .maybeSingle();

  if (error) {
    throw new Error(`Failed to fetch public prompt: ${error.message}`);
  }

  // Return null for both "not found" AND "not public" (security - don't reveal existence)
  if (!data) {
    return null;
  }

  return mapPublicPromptRow(data as PublicPromptRow);
}
```

Key points:
- Use `.maybeSingle()` to return null when not found (not an error)
- Filter by BOTH `id` AND `visibility='public'` to prevent leaking private prompts
- Return null for both "doesn't exist" and "exists but private" (same behavior for security)
- Uses existing `mapPublicPromptRow` to include author info
  </action>
  <verify>TypeScript compiles without errors: `npm run build` passes</verify>
  <done>getPublicPromptById method exists in adapter and interface, returns PublicPrompt | null</done>
</task>

<task type="auto">
  <name>Task 2: Create usePublicPrompt Hook</name>
  <files>src/hooks/usePublicPrompt.ts</files>
  <action>
Create new hook file following usePublicPrompts.ts pattern:

```typescript
import { useQuery, useQueryClient } from '@tanstack/react-query';
import { useStorageAdapterContext } from '@/contexts/StorageAdapterContext';
import type { PublicPrompt } from '@/types/prompt';
import { useEffect } from 'react';

interface UsePublicPromptReturn {
  prompt: PublicPrompt | null;
  loading: boolean;
  error: Error | null;
  refetch: () => Promise<void>;
}

/**
 * Hook for fetching a single public prompt by ID.
 *
 * Uses TanStack Query for caching with 30 second stale time.
 * Requires authentication to use (RLS policy enforces this).
 * Subscribes to realtime updates for public prompts.
 *
 * Returns null for prompts that don't exist OR aren't public (same behavior for security).
 *
 * @param promptId - The UUID of the prompt to fetch
 * @example
 * const { prompt, loading, error, refetch } = usePublicPrompt('abc-123');
 */
export function usePublicPrompt(promptId: string | undefined): UsePublicPromptReturn {
  const { adapter } = useStorageAdapterContext();
  const queryClient = useQueryClient();

  const {
    data,
    isLoading,
    error,
    refetch: queryRefetch,
  } = useQuery({
    queryKey: ['publicPrompt', promptId],
    queryFn: async () => {
      if (!adapter) throw new Error('Storage adapter not available');
      if (!promptId) throw new Error('Prompt ID is required');
      return adapter.prompts.getPublicPromptById(promptId);
    },
    enabled: !!adapter && !!promptId,
    staleTime: 30000, // 30 seconds cache
  });

  // Subscribe to realtime updates for public prompts
  useEffect(() => {
    if (!adapter?.subscribe || !promptId) return;

    const unsubscribe = adapter.subscribe((type) => {
      if (type === 'publicPrompts') {
        // Invalidate this specific prompt query to trigger a refetch
        void queryClient.invalidateQueries({ queryKey: ['publicPrompt', promptId] });
      }
    });

    return () => {
      unsubscribe();
    };
  }, [adapter, promptId, queryClient]);

  const refetch = async () => {
    await queryRefetch();
  };

  return {
    prompt: data ?? null,
    loading: isLoading,
    error: error instanceof Error ? error : null,
    refetch,
  };
}
```

Key patterns (following usePublicPrompts.ts):
- TanStack Query with enabled flag for conditional fetching
- 30 second staleTime for caching
- Realtime subscription for publicPrompts events
- Returns null for missing/private prompts (not an error)
- Query key includes promptId for proper cache isolation
  </action>
  <verify>TypeScript compiles without errors: `npm run build` passes</verify>
  <done>usePublicPrompt hook exists, exports usePublicPrompt function with proper typing</done>
</task>

</tasks>

<verification>
1. `npm run build` passes without TypeScript errors
2. `npm run lint` passes without ESLint errors
3. types.ts includes getPublicPromptById in PromptsStorageAdapter interface
4. supabaseAdapter.ts implements getPublicPromptById method
5. usePublicPrompt.ts exists with named export
</verification>

<success_criteria>
- Storage adapter can fetch single public prompt by ID
- Hook provides loading/error/prompt states with TanStack Query
- Realtime subscription invalidates cache when public prompts change
- Non-existent or private prompts return null (not error)
</success_criteria>

<output>
After completion, create `.planning/phases/15.3-public-prompt-detail-page/15.3-01-SUMMARY.md`
</output>
