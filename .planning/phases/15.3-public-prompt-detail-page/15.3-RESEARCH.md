# Phase 15.3: Public Prompt Detail Page - Research

**Researched:** 2026-01-31
**Domain:** React component composition, route handling, permissions-based rendering
**Confidence:** HIGH

## Summary

This phase extends the existing prompt detail architecture to support viewing public prompts from the Library. The codebase already has a robust foundation with PromptView.tsx (shared presentation logic) and PromptDetail.tsx (Dashboard page wrapper). Research confirms the thin wrapper pattern is the correct approach.

The standard approach in this codebase is to compose shared UI components (PromptView) with page-specific wrappers (PromptDetail for Dashboard, new PublicPromptDetail for Library) that handle routing, data loading, and context-specific features.

**Primary recommendation:** Create PublicPromptDetail.tsx as a thin wrapper around PromptView, using conditional props to hide owner-only actions (Edit, Delete, Version History). Add new storage adapter method to fetch single public prompt by ID. Implement owner detection banner and cross-view navigation buttons.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| React Router v6 | ^7.1.1 | Routing with data API | Used throughout app (App.tsx:55-117) |
| TanStack Query v5 | ^5.64.2 | Server state management | Used by usePublicPrompts hook pattern |
| Supabase JS | ^2.48.1 | Database + RLS | Backend for all data fetching |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| React Hot Toast | ^2.4.1 | User feedback | Success/error notifications (PromptView.tsx) |
| Framer Motion | ^11.18.0 | Page transitions | Smooth navigation (existing pattern) |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| TanStack Query | Raw React state | Would lose caching, invalidation logic. Query is standard. |
| Wrapper pattern | Duplicate PromptView | Would create maintenance burden. Composition is standard. |

**Installation:**
No new dependencies required. All libraries already installed.

## Architecture Patterns

### Recommended Project Structure
```
src/
├── pages/
│   ├── PromptDetail.tsx          # Dashboard wrapper (existing)
│   └── PublicPromptDetail.tsx    # Library wrapper (NEW)
├── components/
│   └── PromptView.tsx            # Shared presentation (existing)
├── hooks/
│   ├── usePublicPrompts.ts       # Fetches all public prompts (existing)
│   └── usePublicPrompt.ts        # Fetch single public prompt (NEW)
└── lib/storage/
    └── supabaseAdapter.ts        # Add getPublicPromptById() (NEW)
```

### Pattern 1: Thin Wrapper Composition
**What:** Page components wrap shared PromptView with page-specific logic
**When to use:** Multiple views of same data with different permissions/context
**Example:**
```typescript
// Source: Existing pattern from PromptDetail.tsx:139-163
export default function PromptDetail() {
  const { promptId } = useParams();
  const { prompts, updatePrompt, deletePrompt } = usePrompts();
  const prompt = prompts.find(p => p.id === promptId);

  return (
    <PromptView
      prompt={prompt}
      onEdit={() => setIsEditing(true)}
      onDelete={handleDelete}
      onNavigateBack={handleNavigateBack}
    />
  );
}

// NEW pattern for PublicPromptDetail.tsx:
export default function PublicPromptDetail() {
  const { promptId } = useParams();
  const { user } = useAuth();
  const { prompt, loading } = usePublicPrompt(promptId);
  const isOwner = prompt?.authorId === user?.id;

  return (
    <PromptView
      prompt={prompt}
      onEdit={undefined}        // Hide edit for non-owners
      onDelete={undefined}      // Hide delete for non-owners
      onNavigateBack={() => navigate('/library')}
      showOwnerBanner={isOwner} // NEW prop
      showVersionHistory={isOwner} // NEW prop
    />
  );
}
```

### Pattern 2: Conditional Action Rendering
**What:** PromptView hides UI elements when handlers are undefined
**When to use:** Permissions-based feature visibility
**Example:**
```typescript
// Source: PromptView.tsx:261-265 (Edit button)
{onEdit && (
  <Button onClick={onEdit}>
    <Edit className="h-4 w-4 mr-2" />
    Edit
  </Button>
)}

// Extend pattern for new props:
{showVersionHistory && (
  <Button onClick={() => setHistoryModalOpen(true)}>
    <History className="h-4 w-4 mr-2" />
    History
  </Button>
)}
```

### Pattern 3: Route-Specific Data Fetching with TanStack Query
**What:** Custom hooks wrap TanStack Query for type-safe, cached data fetching
**When to use:** Fetching server data with caching and realtime invalidation
**Example:**
```typescript
// Source: usePublicPrompts.ts pattern
export function usePublicPrompt(promptId: string) {
  const { adapter } = useStorageAdapterContext();

  const { data, isLoading, error } = useQuery({
    queryKey: ['publicPrompt', promptId],
    queryFn: async () => {
      if (!adapter) throw new Error('Storage adapter not available');
      return adapter.prompts.getPublicPromptById(promptId);
    },
    enabled: !!adapter && !!promptId,
    staleTime: 30000, // 30 seconds cache
  });

  return { prompt: data ?? null, loading: isLoading, error };
}
```

### Pattern 4: Owner Detection and Cross-View Navigation
**What:** Detect when user owns the public prompt they're viewing, show banner + navigation
**When to use:** User viewing their own content in different context
**Example:**
```typescript
// In PublicPromptDetail.tsx:
const { user } = useAuth();
const isOwner = prompt?.authorId === user?.id;

// Pass to PromptView:
<PromptView
  showOwnerBanner={isOwner}
  ownerBannerAction={() => navigate(`/dashboard/prompt/${promptId}`)}
/>

// In PromptView.tsx (NEW):
{showOwnerBanner && (
  <div className="bg-blue-50 border-l-4 border-blue-400 p-4 mb-6">
    <p className="text-sm text-blue-700">
      You're viewing this as others see it.
    </p>
    <Button onClick={ownerBannerAction}>
      View in Dashboard
    </Button>
  </div>
)}
```

### Pattern 5: Symmetric Navigation (Dashboard <-> Library)
**What:** Both views provide navigation to the other for public prompts
**When to use:** User needs to switch perspective on same content
**Example:**
```typescript
// In PromptView.tsx (for Dashboard view of public prompt):
{prompt.visibility === 'public' && (
  <Button variant="outline" onClick={() => navigate(`/library/prompt/${prompt.id}`)}>
    <Globe className="h-4 w-4 mr-2" />
    View Public Version
  </Button>
)}
```

### Anti-Patterns to Avoid
- **Don't duplicate PromptView logic:** PublicPromptDetail should be minimal wrapper, not reimplementation
- **Don't expose edit actions to non-owners:** Use conditional rendering, not RLS failures
- **Don't fetch owned prompts for public view:** Use separate storage method that enforces public visibility
- **Don't reveal prompt existence for private prompts:** Return same 404 whether prompt is private or deleted

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Single public prompt fetch | New fetch logic | Extend SupabasePromptsAdapter | Consistent RLS, error handling, type safety |
| Permission checks | Manual user_id comparison | RLS policies + visibility filter | Database enforces security, prevents leakage |
| Error states (404) | New error component | Existing NotFound.tsx + conditional | Consistent UX, router integration |
| Owner detection | Custom logic | `prompt.authorId === user?.id` | Simple, type-safe, already used for Library cards |
| Navigation between views | Custom routing | React Router Link/navigate | Browser history, keyboard shortcuts work |

**Key insight:** This codebase already has robust patterns for permissions (RLS + visibility), data fetching (TanStack Query hooks), and component composition (wrapper + shared view). Don't reinvent - extend.

## Common Pitfalls

### Pitfall 1: Fetching Owned Prompts Instead of Public Prompts
**What goes wrong:** Using `getPrompts()` instead of dedicated public fetch leaks private prompts
**Why it happens:** Tempting to reuse existing fetch, filter client-side
**How to avoid:** Create separate `getPublicPromptById(id)` that filters by `visibility='public'` in SQL
**Warning signs:** Prompt appears for owner when private, doesn't appear for others

### Pitfall 2: Revealing Prompt Existence for Private Prompts
**What goes wrong:** Different error messages for "not found" vs "private" reveal that prompt exists
**Why it happens:** Helpful error messages leak information
**How to avoid:** Return same 404 error for both cases (prompt doesn't exist OR isn't public)
**Warning signs:** Error message says "This prompt is private" instead of generic 404

### Pitfall 3: Version History Visibility for Non-Owners
**What goes wrong:** Showing version history for public prompts viewed by non-owners
**Why it happens:** PromptView defaults to showing version history button
**How to avoid:** Add `showVersionHistory` prop, only pass true when `isOwner`
**Warning signs:** Version History button appears when viewing others' prompts

### Pitfall 4: Missing Owner Banner
**What goes wrong:** User views their own public prompt via Library, doesn't realize it's different from Dashboard
**Why it happens:** Owner detection logic not implemented
**How to avoid:** Check `prompt.authorId === user?.id`, show banner explaining context
**Warning signs:** User confused why they can't edit their own prompt

### Pitfall 5: Breaking Browser Navigation
**What goes wrong:** Using custom navigation that breaks back button, middle-click, Ctrl+click
**Why it happens:** Manual click handlers instead of proper Links
**How to avoid:** Use React Router `<Link>` components, let router handle navigation
**Warning signs:** Middle-click doesn't open in new tab, back button behaves oddly

### Pitfall 6: RLS Policies Blocking Public Prompt Fetch
**What goes wrong:** New storage method fails because RLS policy requires user_id match
**Why it happens:** Existing RLS policies enforce ownership, not visibility
**How to avoid:** RLS SELECT policy must allow `visibility='public'` for any authenticated user
**Warning signs:** SQL error "new row violates row-level security policy"

## Code Examples

Verified patterns from official sources:

### Fetching Public Prompt by ID (Storage Adapter)
```typescript
// Source: Existing pattern from supabaseAdapter.ts:199-214
async getPublicPromptById(promptId: string): Promise<PublicPrompt | null> {
  // Requires authentication - RLS policy allows reading public prompts for any authenticated user
  await requireUserId();

  const { data, error } = await supabase
    .from('prompts')
    .select('id, user_id, title, body, variables, created_at, updated_at, is_pinned, times_used, visibility')
    .eq('id', promptId)
    .eq('visibility', 'public')  // CRITICAL: Only fetch if public
    .maybeSingle();

  if (error) {
    throw new Error(`Failed to fetch public prompt: ${error.message}`);
  }

  if (!data) {
    return null; // Prompt doesn't exist OR isn't public (same result for security)
  }

  return mapPublicPromptRow(data as PublicPromptRow);
}
```

### Error Handling (Page Component)
```typescript
// Source: Existing pattern from PromptDetail.tsx:116-136
if (!loading && !prompt) {
  return (
    <>
      <Navigation />
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-center max-w-md">
          <AlertCircle className="h-16 w-16 mx-auto mb-4 text-muted-foreground" />
          <h2 className="text-2xl font-semibold mb-2">Prompt Not Found</h2>
          <p className="text-muted-foreground mb-6">
            This prompt doesn't exist or isn't publicly available.
          </p>
          <Button asChild>
            <NavLink to="/library">
              Back to Library
            </NavLink>
          </Button>
        </div>
      </div>
    </>
  );
}
```

### Owner Detection and Banner
```typescript
// NEW pattern for PublicPromptDetail.tsx
const { user } = useAuth();
const isOwner = prompt && prompt.authorId === user?.id;

{isOwner && (
  <div className="bg-blue-50 dark:bg-blue-900/20 border-l-4 border-blue-400 p-4 mb-6 rounded-r-lg">
    <div className="flex items-center justify-between">
      <p className="text-sm text-blue-700 dark:text-blue-300">
        You're viewing this as others see it
      </p>
      <Button
        variant="outline"
        size="sm"
        onClick={() => navigate(`/dashboard/prompt/${promptId}`)}
      >
        View in Dashboard
      </Button>
    </div>
  </div>
)}
```

### Conditional Props Pattern
```typescript
// Source: Existing pattern from PromptView.tsx:54-59
interface PromptViewProps {
  prompt: Prompt;
  onEdit?: () => void;        // undefined = hide edit button
  onDelete?: (promptId: string) => Promise<void>; // undefined = hide delete
  onNavigateBack: () => void;
  showVersionHistory?: boolean; // NEW - defaults to true if not specified
  showOwnerBanner?: boolean;    // NEW - show owner context banner
  ownerBannerAction?: () => void; // NEW - action for "View in Dashboard" button
}

// In component body:
{onEdit && <Button onClick={onEdit}>Edit</Button>}
{onDelete && <Button onClick={() => handleDelete(prompt.id)}>Delete</Button>}
{(showVersionHistory ?? true) && onEdit && <Button onClick={openHistory}>History</Button>}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Separate components per view | Shared PromptView + thin wrappers | Phase 15 (2026-01) | One source of truth for prompt display logic |
| Client-side filtering | SQL visibility filter + RLS | Phase 14 (2026-01) | Security at database level, prevents leaks |
| Manual permission checks | Conditional prop passing | Ongoing pattern | Cleaner component API, fewer bugs |
| Single route for prompts | Context-specific routes (/dashboard/prompt, /library/prompt) | Phase 15.3 (now) | Clear separation of workspace vs community views |

**Deprecated/outdated:**
- localStorage fallback: Removed in favor of Supabase-only (auth required)
- Anonymous access: All features require authentication now

## Open Questions

Things that couldn't be fully resolved:

1. **Should version history be completely hidden or show "owner only" message?**
   - What we know: CONTEXT.md says "Only visible for prompts YOU own" with note "This is your version history"
   - What's unclear: Hide button entirely, or show disabled button with tooltip?
   - Recommendation: Hide entirely (cleaner UX, follows existing conditional rendering pattern)

2. **Should copy events from public prompts appear in copier's global history?**
   - What we know: CONTEXT.md says "Copy events appear in the COPIER's history"
   - What's unclear: Implementation already works this way (copy_events table has user_id of copier)
   - Recommendation: No changes needed, existing behavior matches spec

3. **Globe emoji positioning on public prompt detail page**
   - What we know: CONTEXT.md says "Globe emoji indicator everywhere to distinguish public prompts"
   - What's unclear: Where on detail page? Next to title? In header?
   - Recommendation: Next to title (consistent with PromptCard pattern line 233)

## Sources

### Primary (HIGH confidence)
- Existing codebase patterns:
  - `src/pages/PromptDetail.tsx` - Wrapper pattern reference
  - `src/components/PromptView.tsx` - Shared component with conditional props
  - `src/lib/storage/supabaseAdapter.ts` - Storage adapter patterns (lines 199-214)
  - `src/hooks/usePublicPrompts.ts` - TanStack Query hook pattern
- CONTEXT.md decisions - User-specified architecture choices
- UAT-011 issue description - Problem definition and recommended solution

### Secondary (MEDIUM confidence)
- React Router v6 documentation - Data router API, nested routes
- TanStack Query v5 documentation - Query keys, caching, invalidation
- Supabase RLS documentation - Row-level security patterns

### Tertiary (LOW confidence)
- None - all research based on existing codebase patterns

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All libraries already in use, versions verified in package.json
- Architecture: HIGH - Patterns verified in existing codebase (PromptDetail, PromptView, usePublicPrompts)
- Pitfalls: HIGH - Based on existing UAT issues and RLS patterns in this project

**Research date:** 2026-01-31
**Valid until:** 2026-03-02 (30 days - stable patterns, React Router/TanStack Query mature)
