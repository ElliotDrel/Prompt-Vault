---
phase: 01-database-schema-rls
plan: 01
type: execute
---

<objective>
Create the foundational `prompt_versions` table with proper indexing, constraints, and Row Level Security policies to enable immutable version tracking for prompt edits.

Purpose: Establish the database infrastructure for storing complete version snapshots, ensuring security through RLS, and optimizing query performance with indexes. This phase lays the groundwork for all subsequent version history features.

Output: Migration file creating `prompt_versions` table, indexes, RLS policies matching existing security model, and realtime publication enabled.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/STACK.md
@.planning/codebase/ARCHITECTURE.md
@supabase/migrations/20241028000001_create_prompts_table.sql
@supabase/migrations/20241028000002_create_copy_events_table.sql
@CLAUDE.md

**Established Patterns:**
- UUID primary keys with `gen_random_uuid()`
- `user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE`
- TIMESTAMPTZ for all timestamp columns
- RLS policies: `auth.uid() = user_id` pattern for SELECT, INSERT, UPDATE, DELETE
- Indexes on `user_id`, timestamp columns (DESC), and boolean flags with WHERE clause
- `GRANT ALL ON table TO authenticated`

**Key Decisions from PROJECT.md:**
- Save OLD state on edit, not new state (current prompt always "live")
- Immutable snapshots, not deltas (no reconstruction logic)
- Skip versions for metadata changes (focus on content only)
- Include `is_consolidated` and `consolidation_group_id` for future Phase 8

**Security Model:**
- All version operations scoped to authenticated user via RLS
- CASCADE delete when parent prompt or user is deleted
- No cross-user access to version history

**Remote-Only Workflow (CRITICAL):**
- Create migration file, push with `npx supabase db push`
- NEVER edit applied migrations - create new migration for fixes
- Test with MCP SQL queries or via adapter after push
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create prompt_versions table migration</name>
  <files>supabase/migrations/YYYYMMDDHHMMSS_create_prompt_versions_table.sql</files>
  <action>
Create migration file following existing schema conventions:

**Table structure:**
```sql
CREATE TABLE prompt_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    prompt_id UUID NOT NULL REFERENCES prompts(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    title TEXT NOT NULL,
    body TEXT NOT NULL,
    variables JSONB NOT NULL DEFAULT '[]'::jsonb,
    is_consolidated BOOLEAN DEFAULT false,
    consolidation_group_id UUID DEFAULT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
```

**Indexes for performance:**
- `idx_prompt_versions_prompt_id` on `prompt_id` (frequent JOIN and WHERE)
- `idx_prompt_versions_user_id` on `user_id` (RLS enforcement)
- `idx_prompt_versions_created_at` on `created_at DESC` (time-based ordering)
- Composite index `idx_prompt_versions_prompt_version` on `(prompt_id, version_number)` for unique constraint and version lookups

**Constraints:**
- `UNIQUE (prompt_id, version_number)` - enforce version number uniqueness per prompt
- `CHECK (version_number > 0)` - ensure positive version numbers

**Why these choices:**
- `prompt_id` links to parent prompt, cascades on delete (immutable history dies with prompt)
- `version_number` is INTEGER not auto-increment (application controls numbering)
- Store complete snapshot (title, body, variables) not deltas for simple querying
- `is_consolidated` and `consolidation_group_id` reserved for future Phase 8 (deferred)
- No `updated_at` trigger - versions are immutable, only `created_at` needed
- JSONB for variables matches parent prompts table pattern

**AVOID:**
- Auto-incrementing version_number (application logic controls this)
- Storing diffs/deltas instead of full snapshots
- Adding `updated_at` column (versions never update)
- Using TEXT for consolidation_group_id (UUID for future foreign key)
  </action>
  <verify>
```bash
# Apply migration to remote
npx supabase db push

# Verify table exists with correct structure via MCP
# Query: SELECT column_name, data_type, is_nullable FROM information_schema.columns WHERE table_name = 'prompt_versions' ORDER BY ordinal_position;

# Verify indexes exist
# Query: SELECT indexname, indexdef FROM pg_indexes WHERE tablename = 'prompt_versions';

# Verify constraint exists
# Query: SELECT conname, pg_get_constraintdef(oid) FROM pg_constraint WHERE conrelid = 'prompt_versions'::regclass;
```
  </verify>
  <done>Migration applied successfully, table exists with all columns, indexes, and constraints, no errors from `npx supabase db push`</done>
</task>

<task type="auto">
  <name>Task 2: Create RLS policies for prompt_versions</name>
  <files>Same migration file as Task 1</files>
  <action>
Add RLS policies to the same migration file (append after table creation):

**Enable RLS:**
```sql
ALTER TABLE prompt_versions ENABLE ROW LEVEL SECURITY;
```

**Policies (match existing pattern from prompts table):**
```sql
-- SELECT: Users can view versions of their own prompts
CREATE POLICY "Users can view their own prompt versions" ON prompt_versions
    FOR SELECT USING (auth.uid() = user_id);

-- INSERT: Users can create versions for their own prompts
CREATE POLICY "Users can insert their own prompt versions" ON prompt_versions
    FOR INSERT WITH CHECK (auth.uid() = user_id);

-- No UPDATE policy - versions are immutable after creation

-- DELETE: Users can delete versions of their own prompts (cascade handles this)
CREATE POLICY "Users can delete their own prompt versions" ON prompt_versions
    FOR DELETE USING (auth.uid() = user_id);

-- Grant permissions
GRANT SELECT, INSERT, DELETE ON prompt_versions TO authenticated;
```

**Why no UPDATE policy:**
- Versions are immutable snapshots - once created, never modified
- Only operations needed: SELECT (view history), INSERT (create version), DELETE (cascade from prompt deletion)
- GRANT does not include UPDATE permission

**Security verification:**
- All policies enforce `auth.uid() = user_id` - no cross-user access
- No anonymous access (no policies for anon role)
- Cascading deletes handle cleanup when prompts or users are deleted
  </action>
  <verify>
```bash
# Policies should already be applied from Task 1's db push

# Verify RLS is enabled via MCP
# Query: SELECT relname, relrowsecurity FROM pg_class WHERE relname = 'prompt_versions';

# Verify policies exist
# Query: SELECT policyname, cmd, qual FROM pg_policies WHERE tablename = 'prompt_versions';

# Verify no UPDATE policy exists (should return 0 rows for UPDATE command)
# Query: SELECT policyname FROM pg_policies WHERE tablename = 'prompt_versions' AND cmd = 'UPDATE';
```
  </verify>
  <done>RLS enabled, SELECT/INSERT/DELETE policies active, no UPDATE policy, all policies enforce `auth.uid() = user_id`, GRANT permissions correct</done>
</task>

<task type="auto">
  <name>Task 3: Enable realtime publication for prompt_versions</name>
  <files>New migration file: supabase/migrations/YYYYMMDDHHMMSS_enable_prompt_versions_realtime.sql</files>
  <action>
Create separate migration to enable realtime publication for `prompt_versions` table.

**Migration content:**
```sql
-- Enable realtime for prompt_versions table
-- This allows future realtime subscriptions even though v1 won't actively subscribe
-- Forward compatibility for potential live updates in later versions

-- Add table to supabase_realtime publication
ALTER PUBLICATION supabase_realtime ADD TABLE prompt_versions;
```

**Why separate migration:**
- Follows existing pattern from `20251016170631_enable_realtime.sql` migration
- Clean separation of schema changes (table creation) vs configuration (realtime)
- Easier to review and understand in migration history

**Why enable realtime now:**
- PROJECT.md notes "realtime publication will be enabled for future-proofing"
- No cost to enabling even if v1 doesn't subscribe
- Enables potential future features without schema migration

**What realtime provides (for future):**
- Ability to see version history update live as other sessions create versions
- Background refresh of version list without manual reload
- Currently out of scope per PROJECT.md but infrastructure ready
  </action>
  <verify>
```bash
# Apply migration
npx supabase db push

# Verify prompt_versions is in realtime publication via MCP
# Query: SELECT tablename FROM pg_publication_tables WHERE pubname = 'supabase_realtime' AND tablename = 'prompt_versions';

# Should return one row with tablename = 'prompt_versions'
```
  </verify>
  <done>prompt_versions table added to supabase_realtime publication, migration applied without errors, query confirms table in publication</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npx supabase db push` succeeds for both migrations without errors
- [ ] `npx supabase migration list` shows both migrations as applied on remote
- [ ] MCP query confirms table structure matches specification (columns, types, constraints)
- [ ] MCP query confirms all indexes exist
- [ ] MCP query confirms RLS policies exist (SELECT, INSERT, DELETE only - no UPDATE)
- [ ] MCP query confirms realtime publication includes prompt_versions
- [ ] No TypeScript errors in project (schema change doesn't affect existing code yet)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Migration files follow established naming convention (timestamp prefix)
- No errors or warnings from Supabase CLI
- Table structure ready for Phase 2 (database functions integration)
- RLS policies enforce user isolation matching existing security model
- Realtime enabled for future-proofing
</success_criteria>

<output>
After completion, create `.planning/phases/01-database-schema-rls/01-01-SUMMARY.md`:

# Phase 1 Plan 1: Database Schema & RLS Summary

**Created `prompt_versions` table with indexes, RLS policies, and realtime publication**

## Accomplishments

- Created `prompt_versions` table with UUID primary key, foreign keys to prompts and auth.users
- Implemented immutable snapshot pattern (title, body, variables stored per version)
- Added composite unique constraint on (prompt_id, version_number) for version uniqueness
- Created performance indexes: prompt_id, user_id, created_at, composite (prompt_id, version_number)
- Enabled Row Level Security with SELECT, INSERT, DELETE policies (no UPDATE - immutable)
- Added table to supabase_realtime publication for future-proofing
- Included consolidation fields (is_consolidated, consolidation_group_id) for deferred Phase 8

## Files Created/Modified

- `supabase/migrations/YYYYMMDDHHMMSS_create_prompt_versions_table.sql` - Table, indexes, constraints, RLS policies
- `supabase/migrations/YYYYMMDDHHMMSS_enable_prompt_versions_realtime.sql` - Realtime publication

## Decisions Made

- Separate migration files for schema vs realtime (cleaner history, follows existing pattern)
- Version numbers controlled by application, not database auto-increment
- No UPDATE RLS policy (versions are immutable)
- CASCADE delete on prompt_id and user_id (history dies with prompt)

## Issues Encountered

None

## Next Phase Readiness

- Phase 2 (Database Functions & Type Definitions) can proceed
- Table structure supports all planned CRUD operations
- RLS policies ready for RPC function execution context
- No blockers identified

## Next Step

Ready for Phase 2: Database Functions & Type Definitions (create RPC functions for version CRUD)
</output>
