---
phase: 03-storage-adapter-integration
plan: 02
type: execute
---

<objective>
Integrate version tracking into existing prompt CRUD operations, automatically capturing snapshots on creation and content edits.

Purpose: Wire version history into the user workflow transparentlyâ€”every prompt gets v1 on first edit, every content change gets a snapshot of OLD state before update.
Output: Modified addPrompt and updatePrompt methods that automatically create version snapshots when content changes, skipping metadata-only updates.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-storage-adapter-integration/03-01-SUMMARY.md
@src/lib/storage/supabaseAdapter.ts
@src/types/prompt.ts

**Tech stack available:**
- SupabaseVersionsAdapter with createVersion, getVersions methods (from 03-01)
- SupabasePromptsAdapter with addPrompt, updatePrompt methods
- Supabase RPC functions for version CRUD

**Established patterns:**
- Async operations with try/catch error handling
- requireUserId() for authentication
- Database queries with RLS enforcement
- Error messages with context for debugging

**Constraining decisions:**
- Save OLD state on edit, not new state (PROJECT.md: current prompt always "live")
- Skip versions for metadata changes (PROJECT.md: focus on content only)
- Create v1 on first edit, not prompt creation (PROJECT.md: graceful rollout for existing prompts)
- Content fields: title, body, variables (everything else is metadata)
- Metadata fields: isPinned, timesUsed

**Issues being addressed:**
- Currently no way to recover from accidental prompt edits
- Users hesitant to make major changes due to fear of losing previous versions
</context>

<tasks>

<task type="auto">
  <name>Task 1: Modify addPrompt to create v1 on initial creation</name>
  <files>src/lib/storage/supabaseAdapter.ts</files>
  <action>
Update SupabasePromptsAdapter.addPrompt method to create version 1 snapshot after successful prompt insertion:

1. Keep existing prompt insert logic unchanged (lines 89-111).

2. After successful insert (data received), create version 1 snapshot:
   ```typescript
   const createdPrompt = mapPromptRow(data as PromptRow);

   // Create version 1 snapshot (initial state)
   try {
     await this.versionsAdapter.createVersion({
       promptId: createdPrompt.id,
       versionNumber: 1,
       title: createdPrompt.title,
       body: createdPrompt.body,
       variables: createdPrompt.variables,
     });
   } catch (versionError) {
     // Log but don't fail prompt creation
     console.error('Failed to create initial version:', versionError);
   }

   return createdPrompt;
   ```

3. Add private property `private versionsAdapter: SupabaseVersionsAdapter;` to SupabasePromptsAdapter class and pass it via constructor parameter from SupabaseAdapter.

Why graceful error handling: Version creation failure shouldn't block prompt creation. User gets their prompt, version history starts on first edit instead of creation. Acceptable degradation.
  </action>
  <verify>npm run build succeeds. addPrompt method still returns Prompt. Version creation happens after insert but doesn't throw on failure. Constructor accepts versionsAdapter parameter.</verify>
  <done>addPrompt creates version 1 snapshot after successful prompt insert. Errors logged but don't propagate. SupabasePromptsAdapter has versionsAdapter dependency injected.</done>
</task>

<task type="auto">
  <name>Task 2: Modify updatePrompt with content-detection and OLD state capture</name>
  <files>src/lib/storage/supabaseAdapter.ts</files>
  <action>
Update SupabasePromptsAdapter.updatePrompt method to capture OLD state before changes, with content-detection helper:

1. **Add helper function** (place before SupabasePromptsAdapter class):
   ```typescript
   function hasContentChanges(oldPrompt: Prompt, newData: Omit<Prompt, 'id' | 'updatedAt'>): boolean {
     return (
       oldPrompt.title !== newData.title ||
       oldPrompt.body !== newData.body ||
       JSON.stringify(oldPrompt.variables) !== JSON.stringify(newData.variables)
     );
   }
   ```

2. **Modify updatePrompt method** (lines 114-147):
   - Before update query, fetch current prompt state: `const oldPrompt = await fetchPromptRowById(userId, id);`
   - Check if content changed: `const contentChanged = hasContentChanges(mapPromptRow(oldPrompt), promptData);`
   - If contentChanged, query max version number and create snapshot of OLD state:
     ```typescript
     if (contentChanged) {
       try {
         // Get current max version number
         const { data: versions } = await supabase
           .rpc('get_prompt_versions', { p_prompt_id: id, p_limit: 1 })
           .single();

         const nextVersion = versions ? versions.versions[0]?.version_number + 1 : 1;

         // Create snapshot of OLD state before update
         await this.versionsAdapter.createVersion({
           promptId: id,
           versionNumber: nextVersion,
           title: oldPrompt.title,
           body: oldPrompt.body,
           variables: Array.isArray(oldPrompt.variables) ? oldPrompt.variables as string[] : [],
         });
       } catch (versionError) {
         console.error('Failed to create version snapshot:', versionError);
         // Continue with update even if versioning fails
       }
     }
     ```
   - Then proceed with existing update logic (unchanged).

Why fetch before update: Need OLD state for snapshot AND need to know what version number to assign (max + 1).

Why continue on version error: Metadata-only updates shouldn't create versions. If version creation fails on content change, user's update still succeeds (degraded but functional).
  </action>
  <verify>npm run build succeeds. updatePrompt fetches old state before update. Content changes trigger version snapshot. Metadata-only changes (isPinned, timesUsed) skip versioning. Version errors don't block updates.</verify>
  <done>updatePrompt captures OLD state before content changes. hasContentChanges helper detects content vs metadata updates. Version numbering uses max + 1 from existing versions. Errors handled gracefully.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without TypeScript errors
- [ ] addPrompt creates version 1 snapshot after prompt insert
- [ ] updatePrompt fetches old state and checks for content changes
- [ ] hasContentChanges helper correctly identifies content fields
- [ ] Metadata-only updates (togglePinPrompt, incrementPromptUsage) don't trigger versioning
- [ ] Version creation errors don't block prompt CRUD operations
</verification>

<success_criteria>

- All tasks completed
- TypeScript compilation passes
- Version tracking integrated transparently into CRUD
- Content vs metadata detection works correctly
- Graceful degradation on version errors
- Phase 3 complete, ready for Phase 4 (Diff Engine & Utilities)
</success_criteria>

<output>
After completion, create `.planning/phases/03-storage-adapter-integration/03-02-SUMMARY.md`:

# Phase 3 Plan 2: Integrate version tracking into CRUD Summary

**[Substantive one-liner - what shipped, not "plan complete"]**

## Accomplishments

- Modified addPrompt to create version 1 on initial prompt creation
- Modified updatePrompt to capture OLD state before content changes
- Created hasContentChanges helper to distinguish content from metadata updates
- Implemented graceful error handling (version failures don't block CRUD)
- Version numbering uses max existing version + 1

## Files Created/Modified

- `src/lib/storage/supabaseAdapter.ts` - Modified addPrompt, updatePrompt; added hasContentChanges helper; injected versionsAdapter dependency

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

Phase 3 (Storage Adapter Integration) complete! Ready for Phase 4 (Diff Engine & Utilities).

Version tracking now operates transparently:
- New prompts get v1 on creation
- Content edits create snapshot of OLD state
- Metadata changes skip versioning
- Users never blocked by version system failures
</output>
