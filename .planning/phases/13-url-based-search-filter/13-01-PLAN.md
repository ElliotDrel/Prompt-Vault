---
phase: 13-url-based-search-filter
plan: 01
type: execute
---

<objective>
Sync search queries and filter state to URL params on dashboard, library, and history pages.

Purpose: Enable shareable filter URLs, browser back/forward navigation through filter states, and refresh persistence.
Output: URL params update as users type/filter, and filter state initializes from URL on page load.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-shared-component-architecture/12-02-SUMMARY.md

# Relevant source files:
@src/hooks/usePromptFilters.ts
@src/components/Dashboard.tsx
@src/components/PromptListView.tsx
@src/pages/CopyHistory.tsx
@src/App.tsx

**Tech stack available:**
- React Router v6.26 with data router API (createBrowserRouter)
- useSearchParams hook available for URL sync
- TanStack Query for server state caching

**Established patterns:**
- Controlled component pattern for filter state in usePromptFilters
- Custom hooks for reusable logic (usePromptFilters, usePromptVersions)
- Debounced search in CopyHistory (300ms)

**Constraining decisions:**
- Phase 12: usePromptFilters uses controlled component pattern with state passed from parent
- Phase 12: PromptListView is a presentational component, filter state managed by consumer
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useURLFilterSync hook for URL-search state synchronization</name>
  <files>src/hooks/useURLFilterSync.ts</files>
  <action>
Create a custom hook that bidirectionally syncs filter state with URL search params.

Interface:
```typescript
interface URLFilterConfig {
  searchParam?: string;      // URL param name for search (default: 'q')
  sortByParam?: string;      // URL param name for sortBy (default: 'sort')
  sortDirParam?: string;     // URL param name for sortDirection (default: 'dir')
  authorParam?: string;      // URL param name for author filter (default: 'author')
  debounceMs?: number;       // Debounce delay for URL updates (default: 300)
}

interface UseURLFilterSyncReturn {
  // State (read from URL on mount, synced to URL on change)
  searchTerm: string;
  sortBy: SortBy;
  sortDirection: SortDirection;
  authorFilter: string | null;

  // Setters (update both state and URL)
  setSearchTerm: (term: string) => void;
  setSortBy: (by: SortBy) => void;
  setSortDirection: (dir: SortDirection) => void;
  setAuthorFilter: (author: string | null) => void;
  toggleSortDirection: () => void;
  clearFilters: () => void;
}
```

Implementation details:
- Use useSearchParams from react-router-dom for URL state
- Initialize state from URL params on mount (fallback to defaults if not present)
- Debounce URL updates for searchTerm to avoid URL spam while typing
- Use replace: true for URL updates (don't pollute history with every keystroke)
- Remove empty params from URL (don't show ?q= for empty search)
- Validate sortBy and sortDirection values from URL (fallback to defaults if invalid)
- Export SortBy and SortDirection types from this hook for consistency

Do NOT use setSearchParams inside useEffect for initial sync - read URL params directly in useState initializers to avoid flash of default state.
  </action>
  <verify>TypeScript compiles without errors: npm run build</verify>
  <done>Hook exports useURLFilterSync with URL sync behavior, handles debouncing, and validates URL params</done>
</task>

<task type="auto">
  <name>Task 2: Integrate URL sync into Dashboard</name>
  <files>src/components/Dashboard.tsx, src/hooks/usePromptFilters.ts</files>
  <action>
Update Dashboard to use useURLFilterSync for filter state instead of local useState in usePromptFilters.

Steps:
1. Import useURLFilterSync in Dashboard
2. Use useURLFilterSync to get filter state (searchTerm, sortBy, sortDirection, setters)
3. Pass filter state to usePromptFilters as controlled state (update usePromptFilters to accept external state)
4. Update usePromptFilters to support both controlled and uncontrolled modes:
   - If externalState is provided, use it (controlled mode)
   - Otherwise, use internal useState (uncontrolled mode, backward compatible)

The key change: usePromptFilters becomes a pure filtering/sorting utility that takes state from outside, while useURLFilterSync manages the state with URL persistence.

Dashboard pattern after change:
```typescript
const urlFilters = useURLFilterSync({ debounceMs: 300 });
const { filteredPrompts, isEmpty } = usePromptFilters({
  prompts,
  searchTerm: urlFilters.searchTerm,
  sortBy: urlFilters.sortBy,
  sortDirection: urlFilters.sortDirection,
  pinFirst: true,
});
```

Pass urlFilters setters to PromptListView's onChange handlers.
  </action>
  <verify>
1. npm run build succeeds
2. Navigate to /dashboard
3. Type in search box - URL should update to ?q=searchterm after debounce
4. Click sort buttons - URL should update immediately (?sort=name&dir=asc)
5. Refresh page - filters should persist from URL
6. Use browser back - should return to previous filter state
  </verify>
  <done>Dashboard filters sync to URL, persist on refresh, and support browser navigation</done>
</task>

<task type="auto">
  <name>Task 3: Integrate URL sync into CopyHistory page</name>
  <files>src/pages/CopyHistory.tsx</files>
  <action>
Update CopyHistory page to use useURLFilterSync for its search state.

Steps:
1. Import useURLFilterSync
2. Replace local useState for searchTerm with useURLFilterSync
3. Remove the manual debouncing logic (searchTimeoutRef, useEffect with setTimeout) - useURLFilterSync handles debouncing
4. Keep the searchCopyEvents and clearSearch calls, but trigger them based on URL state changes

Pattern:
```typescript
const { searchTerm, setSearchTerm } = useURLFilterSync({
  searchParam: 'q',
  debounceMs: 300,
});

// Trigger search when URL-synced searchTerm changes
useEffect(() => {
  if (searchTerm) {
    searchCopyEvents(searchTerm);
  } else {
    clearSearch();
  }
}, [searchTerm, searchCopyEvents, clearSearch]);
```

Note: CopyHistory doesn't need sortBy/sortDirection URL sync (it uses server-side chronological ordering). Only sync the search query.
  </action>
  <verify>
1. npm run build succeeds
2. Navigate to /history
3. Type in search box - URL should update to ?q=searchterm after debounce
4. Search results appear after debounce
5. Refresh page - search term persists and results reload
6. Clear search - URL clears to /history
  </verify>
  <done>CopyHistory search syncs to URL and persists on refresh</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm run lint` passes
- [ ] Dashboard: search/sort state persists in URL
- [ ] Dashboard: browser back/forward navigates through filter history
- [ ] Dashboard: refresh preserves filter state
- [ ] CopyHistory: search state persists in URL
- [ ] CopyHistory: refresh preserves search state
- [ ] Empty URL params don't show (?q= should not appear for empty search)
- [ ] Invalid URL params fall back to defaults gracefully
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- URL filter sync works on Dashboard and CopyHistory
- Browser navigation (back/forward) works with filters
- Page refresh preserves filter state
</success_criteria>

<output>
After completion, create `.planning/phases/13-url-based-search-filter/13-01-SUMMARY.md`:

# Phase 13 Plan 01: URL-Based Search/Filter Summary

**[Substantive one-liner describing what shipped]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.ts` - Description

## Decisions Made

[Key decisions and rationale]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

Phase 13 complete. Ready for Phase 14 (Visibility Toggle).
</output>
